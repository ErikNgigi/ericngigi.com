<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AWS on Eric Ngigi</title>
    <link>https://ericngigi.com/tags/aws/</link>
    <description>Recent content in AWS on Eric Ngigi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 02 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://ericngigi.com/tags/aws/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Docker on Linux vs Other Platforms</title>
      <link>https://ericngigi.com/post/docker/docker-linux/</link>
      <pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ericngigi.com/post/docker/docker-linux/</guid>
      <description>&lt;p&gt;Docker stands as a widely-used solution for crafting and executing applications within self-contained containers, offering a lightweight and versatile method that functions across platforms with Docker support. For those contemplating the use of Docker in their projects, the choice between running it on Linux versus other platforms like Windows or Mac may present questions. In this article, we will delve into the advantages and complexities of Docker deployment on Linux, shedding light on crucial factors to weigh when deciding on your preferred platform.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-linux-compatability&#34;&gt;1. Linux Compatability&lt;/h2&gt;
&lt;p&gt;Running Docker on Linux offers a key advantage in its native compatibility with the Linux kernel, serving as the foundational component of the operating system that orchestrates the computer&amp;rsquo;s resources and processes. Consequently, Docker on Linux can harness the full spectrum of the Linux kernel&amp;rsquo;s functionalities, including namespaces, cgroups, and seccomp, ensuring the efficient and secure creation and management of containers. In contrast, on alternative platforms like Windows or Mac, Docker necessitates the utilization of a virtual machine or compatibility layer to accommodate Linux containers. This additional layer introduces some overhead and complexity.&lt;/p&gt;
&lt;h2 id=&#34;2-linux-variety&#34;&gt;2. Linux Variety&lt;/h2&gt;
&lt;p&gt;An added advantage of Docker on Linux is the extensive array of Linux distributions and versions at your disposal, aligning with your specific preferences and requirements. You can opt for a lean and nimble distribution like Alpine or BusyBox, ideal for running Docker containers with minimal resource consumption and dependencies. Alternatively, for enhanced features and steadfast support, you can turn to more feature-rich distributions such as Ubuntu or Debian. This level of flexibility allows you to tailor Docker containers to your precise needs. In contrast, other platforms like Windows or Mac restrict you to the limitations of the underlying operating system and its updates.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-linux-learning-curve&#34;&gt;3. Linux Learning Curve&lt;/h2&gt;
&lt;p&gt;A hurdle in running Docker on Linux lies in the requisite familiarity and ease with the Linux command line and environment, which may not be a given for all users. This includes competencies like installing and updating Docker, configuring and addressing issues with the Docker daemon and network, and employing fundamental Linux commands and tools (e.g., ls, ps, grep, curl, etc.) to interact with containers and the host system. In contrast, Docker on other platforms, such as Windows or Mac, offers a graphical user interface and a desktop application, streamlining and rendering several of these tasks more user-friendly and accessible.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;4-linux-security&#34;&gt;4. Linux Security&lt;/h2&gt;
&lt;p&gt;Yet another obstacle in running Docker on Linux pertains to the inclusion of certain security risks and responsibilities that necessitate your attention and management. These considerations encompass ensuring the security and authentication of your Docker daemon, running containers with the minimum essential privileges and resources, verifying and scanning container images for vulnerabilities, isolating and encrypting network communication, and maintaining a well-patched and protected host system. On alternative platforms like Windows or Mac, Docker offers some built-in security features and defaults that assist in mitigating a portion of these risks.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Evolution From SDLC to a CloudSDLC</title>
      <link>https://ericngigi.com/post/sdlc/cloudsdlc/</link>
      <pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ericngigi.com/post/sdlc/cloudsdlc/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;1-1st-stage-of-the-sdlc-evolution&#34;&gt;1. 1st Stage of the SDLC Evolution&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://ericngigi.com/post/sdlc/sdlc_era_01.png&#34; alt=&#34;SDLC Stage 1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The Waterfall Development Process: This era saw the prominence of the Waterfall development process. The Waterfall model was a structured, linear approach to software development that consisted of sequential phases, such as requirements gathering, system design, implementation, testing, deployment, and maintenance. While it aimed to ensure well-documented and high-quality projects, it suffered from rigidity and difficulty in adapting to changing requirements.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Monolithic Application Architectures: Software applications were primarily built using monolithic architectures. In a monolithic approach, the entire application was developed as a single, self-contained unit. While this approach made development and management straightforward for smaller applications, it was less scalable and flexible, requiring the rebuilding and redeployment of the entire application for any updates or changes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Physical Server Deployment: Software applications were deployed on physical servers, which were actual machines located in data centers or on-premises facilities. This process involved configuring these servers, installing the necessary software, and managing hardware resources. However, it came with challenges related to scalability, resource management, and high infrastructure costs, along with potential issues linked to hardware failures and maintenance.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Datacenter-Based Application Infrastructure: Data centers served as the central hubs for software application infrastructure during this period. These facilities housed servers, networking equipment, and storage devices, providing the computing power and ensuring high availability. However, this model required substantial physical space, complex networking setups, and extensive cooling systems, along with the vulnerability of single points of failure.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-2nd-stage-of-the-sdlc-evolution&#34;&gt;2. 2nd Stage of the SDLC Evolution&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://ericngigi.com/post/sdlc/sdlc_era_02.png&#34; alt=&#34;SDLC Stage 2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;N-Tier Application Architectures: There was a notable transition to n-tier application architectures. These architectures segmented applications into multiple layers or tiers, each responsible for specific functionalities, including the user interface, application logic, and data storage. N-tier architectures offered improved scalability, maintainability, and the ability to update individual components without affecting the entire application, facilitating collaboration among development teams working on different layers simultaneously.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Virtual Server Deployment: This era saw a shift from physical server deployment to virtual server deployment. Virtualization technology enabled the creation of virtual machines (VMs) on a single physical server, allowing multiple operating systems and applications to run independently on the same hardware. Virtual servers offered enhanced flexibility, resource utilization, and simplified server provisioning, contributing to faster deployment and reduced hardware costs. This shift laid the foundation for the emergence of cloud computing and Infrastructure as a Service (IaaS).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hosted Application Infrastructure: With the growing prevalence of the internet and virtualization technology, software applications moved from traditional data centers to hosted environments. Hosted application infrastructures, also known as cloud hosting or Software as a Service (SaaS), allowed businesses to outsource infrastructure management to third-party providers. This approach offered benefits such as scalability, reduced maintenance overhead, and global accessibility. Major providers like Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform (GCP) played a significant role, offering a wide array of services to support various software applications.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-3rd-stage-of-the-sdlc-evolution&#34;&gt;3. 3rd Stage of the SDLC Evolution&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://ericngigi.com/post/sdlc/sdlc_era_03.png&#34; alt=&#34;SDLC Stage 3&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DevOps Development Process: The 2010s saw the emergence of DevOps, a cultural and technical movement fostering collaboration between development and IT operations teams. DevOps promotes continuous integration, continuous delivery (CI/CD), and automation, breaking down traditional silos and accelerating software development while improving quality.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Microservices Application Architecture: The adoption of microservices architecture marked a significant shift, breaking applications into small, independent services connected through APIs. This approach enhances scalability, fault isolation, and maintenance while allowing diverse technologies for each service, though it introduces challenges in orchestration and data consistency.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Containerized Deployment: Containerization has become a dominant method for deploying software, using lightweight, portable containers to package applications and dependencies. Technologies like Docker streamline deployment, ensuring consistent performance across different environments, and facilitating the scaling of microservices.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cloud-Based Application Infrastructure: Cloud computing has become the backbone of modern software development. Providers like AWS, Azure, and GCP offer scalable, cost-effective solutions for hosting applications, storing data, and utilizing managed services. This shift eases adaptation to changing workloads, improves disaster recovery, and reduces capital expenditure on physical infrastructure.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
